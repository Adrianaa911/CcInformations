-- The switch keyword --

else if statements are a great tool if we need to check multiple conditions. In programming, we often find ourselves needing to check multiple values and handling each of them differently. For example:

let groceryItem = 'papaya';

if (groceryItem === 'tomato') {
  console.log('Tomatoes are $0.49');
} else if (groceryItem === 'papaya'){
  console.log('Papayas are $1.29');
} else {
  console.log('Invalid item');
}

In the code above, we have a series of conditions checking for a value that matches a groceryItem variable. Our code works fine, but imagine if we needed to check 100 different values! Having to write that many else if statements sounds like a pain!

A switch statement provides an alternative syntax that is easier to read and write. A switch statement looks like this:


let groceryItem = 'papaya';

switch (groceryItem) {
  case 'tomato':
    console.log('Tomatoes are $0.49');
    break;
  case 'lime':
    console.log('Limes are $1.49');
    break;
  case 'papaya':
    console.log('Papayas are $1.29');
    break;
  default:
    console.log('Invalid item');
    break;
}




// The switch keyword

/*
let groceryItem = 'papaya';

if (groceryItem === 'tomato') {
  console.log('Tomatoes are $0.49');
} else if (groceryItem === 'papaya'){
  console.log('Papayas are $1.29');
} else {
  console.log('Invalid item');
}

A switch statement provides an alternative syntax that is easier to read and write. A switch statement looks like this:

let groceryItem = 'papaya';

switch (groceryItem) {
  case 'tomato':
    console.log('Tomatoes are $0.49');
    break;
  case 'lime':
    console.log('Limes are $1.49');
    break;
  case 'papaya':
    console.log('Papayas are $1.29');
    break;
  default:
    console.log('Invalid item');
    break;
}

// Prints 'Papayas are $1.29'
*/

let athleteFinalPosition = 'first place';
switch (athleteFinalPosition) {
  case 'first place':
  console.log('You get the gold medal!');
  break;
  case 'second place':
  console.log('You get the silver medal!');
  break;
  case 'third place' :
  console.log('You get the bronze medal!');
  break;
  default: 
  console.log('No medal awarded.');
  break;
}



// -- Arrays -- 

//Arrays are JavaScript’s way of making lists. Arrays can store any data types (including strings, numbers, and booleans). Like lists, arrays are ordered, meaning each item has a numbered position.

let newYearsResolutions = ['Keep a journal', 'Take a falconry class', 'Learn to juggle'];
console.log(newYearsResolutions);
 
// -- Create an Array -- 
/*
One way we can create an array is to use an array literal. An array literal creates an array by wrapping items in square brackets []. Remember from the previous exercise, arrays can store any data type — we can have an array that holds all the same data types or an array that holds different data types.
*/
const hobbies = ['Reading books', 'Swimming', 'Learn new languages'];
console.log(hobbies);

// -- Accessing Elements --
/*
Each element in an array has a numbered position known as its index. We can access individual items using their index, which is similar to referencing an item in a list based on the item’s position.
Arrays in JavaScript are zero-indexed, meaning the positions start counting from 0 rather than 1. Therefore, the first item in an array will be at position 0. Let’s see how we could access an element in an array:
*/
const famousSayings = ['Fortune favors the brave.', 'A joke is a very serious thing.', 'Where there is love there is life.'];

const listItem = famousSayings[0];
console.log(famousSayings[2]);
console.log(famousSayings[3]);

//You can also access individual characters in a string using bracket notation and the index
const hey = 'Hello World';
console.log(hey[6]);
// Output: W


// --  Update Elements -- 
// Once you have access to an element in an array, you can update its value.
let seasons = ['Winter', 'Spring', 'Summer', 'Fall'];

seasons[3] = 'Autumn';
console.log(seasons); 
//Output: ['Winter', 'Spring', 'Summer', 'Autumn']
/*
In the example above, the seasons array contained the names of the four seasons.
However, we decided that we preferred to say 'Autumn' instead of 'Fall'.
The line, seasons[3] = 'Autumn'; tells our program to change the item at index 3 of the seasons array to be 'Autumn' instead of what is already there.
*/

// Task: Change the second element of the array groceryList to 'avocados'.
let groceryList = ['bread', 'tomatoes', 'milk'];

groceryList[1] = 'avocados';

// -- Arrays with let and const --
/*
You may recall that you can declare variables with both the let and const keywords. Variables declared with let can be reassigned.
Variables declared with the const keyword cannot be reassigned. However, elements in an array declared with const remain mutable. Meaning that we can change the contents of a const array, but cannot reassign a new array or a different value.
The instructions below will illustrate this concept more clearly. Pay close attention to the similarities and differences between the condiments array and the utensils array as you complete the steps.
*/
let condiments = ['Ketchup', 'Mustard', 'Soy Sauce', 'Sriracha'];

const utensils = ['Fork', 'Knife', 'Chopsticks', 'Spork'];

// Task 1.Below the two existing arrays, re-assign the element in index 0 of condiments to 'Mayo'. 
//Log the updated array, condiments, to the console.
condiments[0] = 'Mayo';
console.log(condiments);

// Task 2.
//Below your code from Step 1, reassign condiments to be a new array that contains a single string ['Mayo']
//Log the result to the console.
//Notice that you can re-assign elements in an array and re-assign an entire new array to a variable declared using the let keyword.
condiments = ['Mayo'];
console.log(condiments);

// Task 3. 
//Below your code from Step 2, re-assign the last item from the utensils array to 'Spoon'.
//Log the updated array to the console.
utensils[3] = 'Spoon';
 console.log(utensils);


// -- The .length property --
// One of an array’s built-in properties is length and it returns the number of items in the array. 
//We access the .length property just like we do with strings. Check the example below:
const objectives = ['Learn a new language', 'Read 52 books', 'Run a marathon'];

console.log(objectives.length); //output 3



// -- The method .push() --> allows us to add items to the end of an array. Here is an example of how this is used:

const itemTracker = ['item 0', 'item 1', 'item 2'];

itemTracker.push('item 3', 'item 4');

console.log(itemTracker); 
// Output: ['item 0', 'item 1', 'item 2', 'item 3', 'item 4'];


const chores = ['wash dishes', 'do laundry', 'take out trash'];

chores.push('Wipe out the dust', 'Vaccum the house');
console.log(chores);
//Outout: ['wash dishes', 'do laundry', 'take out trash', 'Wipe out the dust', 'Vaccum the house'];


// -- The .pop() Method

//Another array method, .pop(), removes the last item of an array.

const newItemTracker = ['item 0', 'item 1', 'item 2'];

const removed = newItemTracker.pop();

console.log(newItemTracker); 
// Output: [ 'item 0', 'item 1' ]
console.log(removed);
// Output: item 2

/*
In the example above, calling .pop() on the newItemTracker array removed item 2 from the end.
.pop() does not take any arguments, it simply removes the last element of newItemTracker.
.pop() returns the value of the last element. In the example, we store the returned value in a variable removed to be used for later.
.pop() is a method that mutates the initial array.
When you need to mutate an array by removing the last element, use .pop().
*/




// Some arrays methods that are available to JavaScript developers include: 
// .join(), .slice(), .splice(), .shift(), .unshift(), and .concat() amongst many others. 
//Using these built-in methods makes it easier to do some common tasks when working with arrays.

const daysOfWeek = [
  'Monday',
  'Tuesday',
  'Wednesday',
  'Thursday',
  'Friday',
  'Saturday',
  'Sunday',
];

const remove = daysOfWeek.shift();

console.log('Removed day:', remove);

console.log('Rest of week:', daysOfWeek);

// Task 1
// Use the .shift() method to remove the first item from the array groceryList.
// Log the new groceryList to the console.
const groceryList = ['orange juice', 'bananas', 'coffee beans', 'brown rice', 'pasta', 'coconut oil', 'plantains'];
groceryList.shift();
console.log(groceryList);


// Task 2 
// Under the code added in step 1, use the .unshift() method to add 'popcorn' to the beginning of your grocery list.
// After calling .unshift() on groceryList, log groceryList to the console.
// You may wish to delete the console.log() statement from the previous step.
groceryList.unshift('popcorn');
console.log(groceryList);


// Task 3
/*
You’re in a hurry so you decide to ask a friend to help you with your grocery shopping. You want him to pick up the 'bananas', 'coffee beans', and 'brown rice'.

Under the code you added for step 2, use .slice() to provide your friend with a list of these three things.

Log this part of the list to the console. Unlike the two previous checkpoints, you should do both of these steps in one line.
*/

console.log(groceryList.slice(1, 4));
console.log(groceryList);


// Task 4:
// After calling .slice() on groceryList
// log the grocery list to the console one more time.
console.log(groceryList);

// Notice that the groceryList array still contains the same items it had in Step 2. 
//That means .slice() is non-mutating!
// You can confirm this in the link in the previous step.

// Task 5:
// Let’s find the index of a particular element in groceryList 
// using .indexOf().

// Call .indexOf() on groceryList to find the index of the element 'pasta' 
// and save the returned value to a const variable named pastaIndex.
const pastaIndex = groceryList.indexOf('pasta');

// Then log pastaIndex to the console.
// (You may remove the other console.log() statements to declutter the terminal.)



// -- Arrays and Functions --
// what happens if we try to change an array inside a function? 

// Take a look at the following example where we call 
// Exemple: 
 // .push() on an array inside a function. 
 //Recall, the .push() method mutates, or changes, an array:
 const flowers = ['peony', 'daffodil', 'marigold'];

function addFlower(arr) {
  arr.push('lily');
}

addFlower(flowers);

console.log(flowers); // Output: ['peony', 'daffodil', 'marigold', 'lily']

/*
Let’s go over what happened in the example:

The flowers array that has 3 elements.
The function addFlower() has a parameter of arr uses .push() to add a 'lily' element into arr.
We call addFlower() with an argument of flowers which will execute the code inside addFlower.
We check the value of flowers and it now includes the 'lily' element! The array was mutated!
*/


// -- Nested Arrays --
//arrays can store other arrays. 
//When an array contains another array it is known as a nested array. Examine the example below:

const nestedArr = [[1], [2, 3]];

// To access the nested arrays we can use bracket notation with the index value,
// just like we did to access any other element:

console.log(nestedArr[1]); // Output: [2, 3]

/*
Notice that nestedArr[1] will grab the element in index 1 which is the array [2, 3].
Then, if we wanted to access the elements within the nested array we can chain, 
or add on, more bracket notation with index values.
*/

console.log(nestedArr[1]); // Output: [2, 3]
console.log(nestedArr[1][0]); // Output: 2

/*
In the second console.log() statement, 
we have two bracket notations chained to nestedArr. 
We know that nestedArr[1] is the array [2, 3]. 
Then to grab the first element from that array, 
we use nestedArr[1][0] and we get the value of 2.
*/

//Task 1
/*
Let’s make a nested array! Create a variable numberClusters. Assign as its value an array with three array elements.

The first array element should hold the elements 1 and 2 in that order.
The second array element should hold the elements 3 and 4 in that order.
The third array element should hold the elements 5 and 6 in that order. */
const numberClusters = [[1, 2], [3, 4], [5, 6]];

// Task 2:
//Awesome, you made a nested array! 
//Now declare a variable named target using the const keyword 
//and assign to access the element 6 inside numberClusters.
const target = numberClusters[2][1];

//Review Arrays tasks:
//Use the .length property to find the last element of an array.

//Use the other methods in MDN documentation not mentioned in the lesson.

//Take all the elements in an array and make a string.

// Find the return value of calling .push() on an array.

//Nest an array within an array.

//Access an element in the nested array.

// Prints 'Papayas are $1.29'

The switch keyword initiates the statement and is followed by ( ... ), which contains the value that each case will compare. In the example, the value or expression of the switch statement is groceryItem.
Inside the block, { ... }, there are multiple cases. The case keyword checks if the expression matches the specified value that comes after it. The value following the first case is 'tomato'. If the value of groceryItem equalled 'tomato', that case‘s console.log() would run.
The value of groceryItem is 'papaya', so the third case runs— Papayas are $1.29 is logged to the console.
The break keyword tells the computer to exit the block and not execute any more code or check any other cases inside the code block. Note: Without break keywords, the first matching case will run, but so will every subsequent case regardless of whether or not it matches—including the default. This behavior is different from if/else conditional statements that execute only one block of code.
At the end of each switch statement, there is a default statement. If none of the cases are true, then the code in the default statement will run.
